## Networks and Distributed Computing 

**用 python 实现 UDP 的16位校验和** <br/>
源代码在[这里](https://github.com/Rea1One/UDP_CHECK)<br/>
检验课本3.3.2节的计算如下<br/>
![UDP_Check](https://github.com/Rea1One/images/blob/master/UDP_Check.png)<br/>
<br/>
<br/>
<br/>
**P1 Solution:** <br/>
a.从A向S发送报文段，源端口号为A的端口号，目的端口号为23；<br/>
b.从B向S发送报文段，源端口号为B的端口号，目的端口号为23；<br/>
c.从S向A发送报文段，源端口号为23，目的端口号为A的端口号；<br/>
d.从S向B发送报文段，源端口号为23，目的端口号为B的端口号；<br/>
e.可能相同，因为A和B的ip不同，从而S可以区分两者发送的报文；<br/>
d.不可能相同，因为A和B的ip相同，S无法区分两者发送的报文；<br/>
<br/>
<br/>
<br/>
**P3 Solution:**<br/>
01010011+01100110=10111001<br/>
10111001+01110100=00101110<br/>
取反，得校验和为11010001<br>
为了检测错误，接收方添加四个单词(三个原始单词和校验和)。如果和包含一个零，接收器知道有一个错误。所有的一位错误都会被检测到，但是两位错误可以不被检测到(例如，如果第一个单词的最后一个数字被转换为0，第二个单词的最后一个数字被转换为1)。
